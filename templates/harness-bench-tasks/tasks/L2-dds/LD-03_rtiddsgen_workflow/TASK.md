# Task: RTI DDS Gen Workflow

## Critical Development Principle

**TEST EARLY, TEST OFTEN** - Test each step before moving to the next.

## Background: DynamicData vs Generated Types

So far you've used **DynamicData** - runtime type definition:
```python
hello_type = dds.StructType("HelloWorld")
hello_type.add_member(dds.Member("message", dds.StringType(256)))
```

Production systems often use **Generated Types** - compile-time types from IDL:
```python
from HelloWorld import HelloWorld  # Generated by rtiddsgen
sample = HelloWorld()
sample.message = "Hello"
```

Benefits of generated types:
- Type safety at compile time
- Better performance
- IDE autocomplete
- Standard across all DDS implementations

## Your Task

Complete the rtiddsgen workflow:

1. **Write IDL file** (`HelloWorld.idl`)
2. **Run rtiddsgen** to generate Python code
3. **Create publisher** using generated types
4. **Create subscriber** using generated types
5. **Verify** they communicate

## Step 1: Write IDL File

Create `HelloWorld.idl`:

```idl
// HelloWorld.idl
struct HelloWorld {
    string<256> message;
    long count;
};
```

IDL syntax notes:
- `string<N>` = bounded string of max N chars
- `long` = 32-bit signed integer (maps to Python int)
- `double` = 64-bit float
- `boolean` = true/false

## Step 2: Run rtiddsgen

Generate Python type support:

```bash
# Environment: $NDDSHOME must be set
$NDDSHOME/bin/rtiddsgen -language python -d . HelloWorld.idl
```

This generates:
- `HelloWorld.py` - Type definition
- (possibly other support files)

## Step 3: Create Publisher

```python
#!/usr/bin/env python3
import time
import rti.connextdds as dds
from HelloWorld import HelloWorld  # Import generated type

participant = dds.DomainParticipant(0)

# Topic uses the GENERATED type, not DynamicData
topic = dds.Topic(participant, "HelloWorld", HelloWorld)

publisher = dds.Publisher(participant)
writer = dds.DataWriter(publisher, topic)

time.sleep(2.0)  # Discovery

for i in range(1, 11):
    sample = HelloWorld()  # Instantiate generated type
    sample.message = f"Hello World {i}"
    sample.count = i
    writer.write(sample)
    time.sleep(0.5)

time.sleep(1.0)
```

**Key differences from DynamicData:**
- `dds.Topic` not `dds.DynamicData.Topic`
- `dds.DataWriter` not `dds.DynamicData.DataWriter`
- `HelloWorld()` not `dds.DynamicData(hello_type)`
- `sample.message = ...` not `sample["message"] = ...`

## Step 4: Create Subscriber

```python
#!/usr/bin/env python3
import json
import time
import rti.connextdds as dds
from HelloWorld import HelloWorld

participant = dds.DomainParticipant(0)
topic = dds.Topic(participant, "HelloWorld", HelloWorld)

subscriber = dds.Subscriber(participant)
reader = dds.DataReader(subscriber, topic)

# WaitSet pattern (same as DynamicData)
waitset = dds.WaitSet()
condition = dds.ReadCondition(reader, dds.DataState.any_data)
waitset.attach_condition(condition)

received = 0
while received < 10:
    active = waitset.wait(dds.Duration.from_seconds(5.0))
    if condition in active:
        for sample in reader.take():
            if sample.info.valid:
                # Access via attributes, not dictionary
                output = {
                    "message": sample.data.message,
                    "count": sample.data.count,
                }
                print(json.dumps(output))
                received += 1
```

## Testing Your Code

```bash
# Step 1: Generate types
$NDDSHOME/bin/rtiddsgen -language python -d . HelloWorld.idl

# Step 2: Run subscriber (Terminal 1)
python subscriber.py

# Step 3: Run publisher (Terminal 2)
python publisher.py
```

## Tools to Help You

### Verify rtiddsgen worked
```bash
# Check generated file exists
ls -la HelloWorld.py

# Check it's valid Python
python -c "from HelloWorld import HelloWorld; print(HelloWorld)"
```

### Verify with dds-spy-wrapper
```bash
# Even with generated types, spy can see the data
dds-spy-wrapper --domain 0 --duration 15
```

## CRITICAL: DDS Interoperability Requirements

**Topic name must be EXACTLY `"HelloWorld"`.** Not `"HelloWorldTopic"`, not `"hello_world"`. The topic name must match character-for-character between publisher and subscriber.

**Both publisher and subscriber MUST use generated types.** This task is specifically about using rtiddsgen-generated types (NOT DynamicData). Generated types and DynamicData may NOT interoperate with each other.

## Common Mistakes

1. **Wrong import**: `from HelloWorld import HelloWorld` (not `import HelloWorld`)
2. **Using DynamicData APIs**: `dds.Topic` not `dds.DynamicData.Topic`
3. **Dictionary access**: `sample.data.message` not `sample.data["message"]`
4. **Forgetting to run rtiddsgen**: Generated file must exist
5. **Wrong topic name**: Must be exactly `"HelloWorld"`

## Success Criteria

- [ ] HelloWorld.idl is valid IDL
- [ ] rtiddsgen generates Python code
- [ ] Publisher uses generated types correctly
- [ ] Subscriber uses generated types correctly
- [ ] Both communicate successfully
- [ ] 10 samples received


